use rand::{distributions::Uniform, rngs::OsRng, Rng};
use sha2::{Digest, Sha256};

const TOKEN_LENGTH: usize = 32;

pub(crate) struct SecureToken {
    sha256: Vec<u8>,
}

impl SecureToken {
    pub(crate) fn generate(kind: SecureTokenKind) -> NewSecureToken {
        let plaintext = format!(
            "{}{}",
            kind.prefix(),
            generate_secure_alphanumeric_string(TOKEN_LENGTH)
        );
        let sha256 = Sha256::digest(plaintext.as_bytes()).as_slice().to_vec();

        NewSecureToken {
            plaintext,
            inner: Self { sha256 },
        }
    }

    pub(crate) fn parse(kind: SecureTokenKind, plaintext: &str) -> Option<Self> {
        // This will both reject tokens without a prefix and tokens of the wrong kind.
        if SecureTokenKind::from_token(plaintext) != Some(kind) {
            return None;
        }

        let sha256 = Sha256::digest(plaintext.as_bytes()).as_slice().to_vec();
        Some(Self { sha256 })
    }

    pub(crate) fn sha256(&self) -> &[u8] {
        &self.sha256
    }
}

pub(crate) struct NewSecureToken {
    plaintext: String,
    inner: SecureToken,
}

impl NewSecureToken {
    pub(crate) fn plaintext(&self) -> &str {
        &self.plaintext
    }
}

impl std::ops::Deref for NewSecureToken {
    type Target = SecureToken;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

fn generate_secure_alphanumeric_string(len: usize) -> String {
    const CHARS: &[u8] = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    OsRng
        .sample_iter(Uniform::from(0..CHARS.len()))
        .map(|idx| CHARS[idx] as char)
        .take(len)
        .collect()
}

macro_rules! secure_token_kind {
    ($(#[$attr:meta])* $vis:vis enum $name:ident { $($key:ident => $repr:expr,)* }) => {
        $(#[$attr])*
        $vis enum $name {
            $($key,)*
        }

        impl $name {
            fn from_token(token: &str) -> Option<Self> {
                $(
                    if token.starts_with($repr) {
                        return Some(Self::$key);
                    }
                )*
                None
            }

            fn prefix(&self) -> &'static str {
                match self {
                    $(
                        Self::$key => $repr,
                    )*
                }
            }
        }
    }
}

secure_token_kind! {
    /// Represents every kind of secure token generated by crates.io. When you need to generate a
    /// new kind of token you should also add its own kind with its own unique prefix.
    ///
    /// NEVER CHANGE THE PREFIX OF EXISTING TOKEN TYPES!!! Doing so will implicitly revoke all the
    /// tokens of that kind, distrupting production users.
    #[derive(Debug, Copy, Clone, Eq, PartialEq)]
    pub(crate) enum SecureTokenKind {
        API => "cio", // Crates.IO
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generated_and_parse() {
        const KIND: SecureTokenKind = SecureTokenKind::API;

        let token = SecureToken::generate(KIND);
        assert!(token.plaintext().starts_with(KIND.prefix()));
        assert_eq!(
            token.sha256(),
            Sha256::digest(token.plaintext().as_bytes()).as_slice()
        );

        let parsed =
            SecureToken::parse(KIND, &token.plaintext()).expect("failed to parse back the token");
        assert_eq!(parsed.sha256(), token.sha256());
    }

    #[test]
    fn test_parse_no_kind() {
        assert!(SecureToken::parse(SecureTokenKind::API, "nokind").is_none());
    }
}
